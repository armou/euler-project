# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?


def get_divisers_amount_approx(n):
    i = 2
    res = 1
    while i <= n / 360: ## 360 is 4 * 9 * 10
        if not n % i:
            res += 1
        i += 1
    return res

def get_divisers_amount_precise(n):
    i = 2
    res = 1
    while i <= n / 2:
        if not n % i:
            res += 1
        i += 1
    return res

def get_greatest_divisible_triangle_number(r):
    sum_triangle, res, i = 0, 0, 1

    while res < r:
        sum_triangle += i
        i += 1
        ## Here we're trying to improve the iteration speed by filtering factors with 2^2, 3^2 and 10 which are common in all high composite numbers
        ## It's not based on any hard rule of math, just brute force try and retry (so of course it could be improved)
        ## This will likely cause false results if r is too low
        if sum_triangle % 4 or sum_triangle % 9 or sum_triangle % 10:
            continue
        hard_factors = 3
        if not sum_triangle % 16: ## 2 ^ 3
            hard_factors += 1
        if not sum_triangle % 17:
            hard_factors += 1    
        if not sum_triangle % 13:
            hard_factors += 1       
        if not sum_triangle % 11:
            hard_factors += 1 
        if not sum_triangle % 7:
            hard_factors += 1 
        ## Let's calculate factors only if at least 6 of above divisors are present
        if hard_factors > 5:
            res = get_divisers_amount_approx(sum_triangle) ## Get approximation of 'res' first to improve speed
            if res > int(r * 0.8):
                res = get_divisers_amount_precise(sum_triangle)
            ## Uncomment below lines to check the amount of numbers that pass the filter
            ## We usually only get numbers that have above 200 divisors which means our filter is pretty good
            # print("number ", sum_triangle)
            # print("has divisers :", res)
    return sum_triangle

print(get_greatest_divisible_triangle_number(500))

##76576500 -- Here is the answer because my code is waaaaay too slow.